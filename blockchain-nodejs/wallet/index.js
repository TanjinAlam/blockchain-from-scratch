const ChainUtil = require("../chain-util");
const { INITIAL_BALANCE } = require("../config");
const Transaction = require("./transaction");
const {
  writeWallets,
  getWallets,
  getWalletAddressFromName,
  getWalletByPrivateKey,
  getTransactionsPool,
  writeTransactionsPool,
} = require("../helper");
class Wallet {
  /**
   * the wallet will hold the public key
   * and the private key pair
   * and the balance
   */
  constructor() {
    this.balance = INITIAL_BALANCE;
    this.keyPair = ChainUtil.genKeyPair();
    this.publicKey = this.keyPair.getPublic();
    this.privateKey = this.keyPair.getPrivate("hex");
  }

  toString() {
    return `
        privateKey: ${this.privateKey.toString()}
        publicKey: ${this.publicKey.toString()}
        balance  : ${this.balance}`;
  }

  getWallet() {
    return {
      privateKey: this.privateKey,
      publicKey: this.publicKey.encodeCompressed("hex"),
      balance: this.balance,
    };
  }

  sign(dataHash) {
    return this.keyPair.sign(dataHash);
  }

  update(transactionIndex, transaction, senderWallet, recipient, amount) {
    if (amount > senderWallet.amount) {
      console.log(`Amount ${amount} exceeds balance`);
      return;
    }
    // let
    console.log("update transaction", transaction);
    transaction.outputs = [
      { amount: amount, address: recipient },
      ...transaction.outputs,
    ];
    // senderWallet.balance = senderWallet.balance - amount;

    Transaction.signTransaction(transaction, senderWallet);
    let transactions = getTransactionsPool();
    transactions[transactionIndex] = transaction;

    this.updateChangeBalance(
      transactions[transactionIndex],
      senderWallet,
      amount
    );
    // transactions[transactionIndex].input.amount =
    //   transactions[transactionIndex].input.amount - amount;
    writeTransactionsPool(transactions);
  }

  updateChangeBalance(transaction, wallet, sendAmount) {
    transaction.outputs.map((e) => {
      if (e.address == wallet.publicKey) {
        e.amount = e.amount - sendAmount;
        return;
      }
    });
  }

  /**
   * Does transactionPool have pending transaction
   */
  checkPendingTransaction() {
    return getTransactionsPool().length > 0 ? true : false;
  }
  /**
   * combines the functionality to create a new transaction
   * update a transaction into one and also update the transaction
   * pool if the transaction exists already.
   */

  createTransaction(
    senderWallet,
    recipient,
    amount,
    blockchain,
    transactionPool,
    transactionPoolData
  ) {
    let transactionIndex = -1;
    this.balance = this.calculateBalance(blockchain, senderWallet);
    // checking send ammount is less than current amount
    if (amount > this.balance) {
      console.log(
        `Amount: ${amount} exceeds the current balance: ${this.balance}`
      );
      return;
    }
    console.log("amountamountamount", this.checkPendingTransaction());
    if (this.checkPendingTransaction()) {
      console.log("transactionPool", transactionPoolData);
      transactionIndex = transactionPool.existingTransaction(
        senderWallet.publicKey.toString(),
        transactionPoolData
      );
    }

    console.log("transactionIndex", transactionIndex);

    if (transactionIndex >= 0) {
      // creates more outputs
      transactionPool.transactions[transactionIndex] = this.update(
        transactionIndex,
        transactionPoolData[transactionIndex],
        senderWallet,
        recipient,
        amount
      );
    } else {
      // creates a new transaction and updates the transaction pool

      let transaction = Transaction.newTransaction(
        transactionIndex,
        senderWallet,
        recipient,
        amount
      );
      // transactionPool.updateOrAddTransaction(transaction);
    }
  }

  /**
   * updates the balance of the wallet
   * based on the latest transaction
   */

  calculateBalance(blockchain, wallet) {
    // store the existing balance
    let balance = this.balance;

    // create an array of transactions
    let transactions = [];

    // store all the transactions in the array
    blockchain.chain.forEach((block) =>
      block.data.forEach((transaction) => {
        transactions.push(transaction);
      })
    );
    // console.log("transactions", wallet.address);
    // console.log("transactions", transactions);
    // transactions.map((tx) => {
    //   console.log("tx.input", tx.input);
    // });
    // console.log("this.publicKey", this.publicKey.toString());
    // get all the transactions generated by the wallet ie money sent by the wallet
    const walletInputTransactions = transactions.filter(
      (transaction) =>
        transaction.input.address.toString() === wallet.publicKey.toString()
    );

    // declare a variable to save the timestamp
    let startTime = 0;

    if (walletInputTransactions.length > 0) {
      // get the latest transaction
      const recentInputTransaction = walletInputTransactions.reduce(
        (prev, current) =>
          prev.input.timestamp > current.input.timestamp ? prev : current
      );

      // get the outputs of that transactions, its amount will be the money that we would get back
      balance = recentInputTransaction.outputs.find(
        (output) => output.address.toString() === wallet.publicKey.toString()
      ).amount;

      // save the timestamp of the latest transaction made by the wallet
      startTime = recentInputTransaction.input.timestamp;
    }

    // get the transactions that were addressed to this wallet ie somebody sent some moeny
    // and add its ouputs.
    // since we save the timestamp we would only add the outputs of the transactions recieved
    // only after the latest transactions made by us

    transactions.forEach((transaction) => {
      if (transaction.input.timestamp > startTime) {
        transaction.outputs.find((output) => {
          if (output.address.toString() === wallet.publicKey.toString()) {
            balance += output.amount;
          }
        });
      }
    });
    return balance;
  }

  static blockchainWallet() {
    const blockchainWallet = new this();
    blockchainWallet.address = "blockchain-wallet";
    return blockchainWallet;
  }
}

module.exports = Wallet;
